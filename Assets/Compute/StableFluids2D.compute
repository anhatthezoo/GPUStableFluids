// Kernels
#pragma kernel UpdateDisplay
#pragma kernel GenerateAtmoLUT
#pragma kernel ResetThermodynamics
#pragma kernel AddValue
#pragma kernel Advection
#pragma kernel ApplyForces
#pragma kernel UpdateThermodynamics
#pragma kernel ProjectionPt1
#pragma kernel ProjectionPt2
#pragma kernel ProjectionPt3
#pragma kernel SetBoundsX
#pragma kernel SetBoundsY

// Setup parameters
uint2 _Resolution;

// Fluid parameters
float _Vorticity;
float _DeltaTime;

// Add parameters
float _AddRadius;
float2 _AddPosition;
float3 _AddValue;

// Buffers
Texture2D<float3> _XIn;  // Generic input buffer
RWTexture2D<float3> _XOut;  // Generic output buffer
RWTexture2D<float> _PressureIn;
RWTexture2D<float> _PressureOut;
RWTexture2D<float> _Divergence;
RWTexture2D<float2> _Velocity;
RWTexture2D<float4> _Thermo;
RWTexture2D<float2> _AtmoLUT;
RWTexture2D<float4> _DisplayTexture;

#include "./Thermodynamics.hlsl"

uint2 ClampID(uint2 id) {
	return clamp(id, uint2(0, 0), uint2(_Resolution.x - 1, _Resolution.y - 1));
}

[numthreads(8, 8, 1)]
void UpdateDisplay(uint2 id : SV_DispatchThreadID) {
	if (any(id >= _Resolution))
		return;

	_DisplayTexture[id] = float4(_XIn[id].y * 1000.0, 0.0, 0.0, 1.0);
}

///////////////////////////////////////////////////////////////////////////
// Add Value
///////////////////////////////////////////////////////////////////////////
[numthreads(8, 8, 1)]
void AddValue(uint2 id : SV_DispatchThreadID) {
	if (any(id >= _Resolution))
		return;
	
	float x = distance(id, _AddPosition);
	float c = _AddRadius;
	float gaussian = exp(-x*x/(2*c*c));
	
	_XOut[id] += _AddValue * gaussian;
}

[numthreads(64, 1, 1)]
void GenerateAtmoLUT(uint2 id : SV_DispatchThreadID) {
	if (id.x >= _Resolution.y)
        return;

	float altitude = getHeightInVolume((float)id.x);
	float airPressure = getAirPressure(altitude);
	float localTemp = getAbsoluteTemperature(altitude);

	_AtmoLUT[id.xy] = float2(localTemp, airPressure);
}

[numthreads(8, 8, 1)]
void ResetThermodynamics(uint2 id : SV_DispatchThreadID) {
	if (any(id >= _Resolution))
		return;
	
	float2 thermoState = getAmbientThermoState(id.y);
	_Thermo[id] = float4(thermoState.x, 0.0, thermoState.y, 0.0);
}

///////////////////////////////////////////////////////////////////////////
// Advection
///////////////////////////////////////////////////////////////////////////
[numthreads(8, 8, 1)]
void Advection(uint2 id : SV_DispatchThreadID)
{
	if (any(id >= _Resolution))
		return;

	float2 dt0 = _DeltaTime * (_Resolution - 2);
	float2 vec = float2(id) - dt0 * _Velocity[id];
	vec = clamp(vec, 0.5, (_Resolution - 2) + 0.5);

	uint2 xy0 = (uint2) vec;
	uint2 xy1 = xy0 + 1;

	float2 st1 = vec - xy0;
	float2 st0 = 1 - st1;

	_XOut[id] = 
		st0.x * (st0.y * _XIn[xy0] +
			     st1.y * _XIn[uint2(xy0.x, xy1.y)]) +
		st1.x * (st0.y * _XIn[uint2(xy1.x, xy0.y)] +
			     st1.y * _XIn[xy1]);
}

float Curl(uint2 id) 
{
	return _Velocity[uint2(id.x, id.y + 1)].x - _Velocity[uint2(id.x, id.y - 1)].x +
		   _Velocity[uint2(id.x - 1, id.y)].y - _Velocity[uint2(id.x + 1, id.y)].y; 
}

[numthreads(8, 8, 1)]
void ApplyForces(uint2 id : SV_DispatchThreadID) 
{
	if (any(id >= _Resolution))
		return;

	float2 dir; 
	dir.x = abs(Curl(uint2(id.x, id.y - 1))) - abs(Curl(uint2(id.x, id.y + 1)));
	dir.y = abs(Curl(uint2(id.x + 1, id.y))) - abs(Curl(uint2(id.x - 1, id.y)));

	dir = dir * (_Vorticity / (length(dir) + 0.00001));
	float2 vorticityForce = (_DeltaTime * Curl(id) * dir);

	float4 thermo = _Thermo[id];
    float q_v = thermo.x;
    float q_c = thermo.y;
    float theta = thermo.z;

    float2 ambientState = getAmbientThermoState(id.y);
    float qv_ambient = ambientState.x;
    float theta_ambient = ambientState.y;

    float theta_v = theta * (1.0 + 0.61 * q_v);
    float theta_v_ambient = theta_ambient * (1.0 + 0.61 * qv_ambient);

    // --- Improved buoyancy ---
    float relativeTheta = (theta_v - theta_v_ambient) / max(theta_v_ambient, 1e-4);
    float buoyancyThreshold = 0.0002;          // tune
    relativeTheta = max(relativeTheta - buoyancyThreshold, 0.0);

    float buoyancyScale = 0.4;               // tune
    float buoyancyMax = 3.0;                  // tune
    float buoyancyForceTemperature = G * buoyancyScale * relativeTheta;
    buoyancyForceTemperature = min(buoyancyForceTemperature, buoyancyMax);

    float buoyancyForceCondensate = -G * 0.001 * (q_c * 1000.0);

    float height01 = saturate((id.y - 1.0) / 6.0);

    float2 buoyancyForce = float2(0.0, (buoyancyForceTemperature + buoyancyForceCondensate) * height01) * _DeltaTime;
	buoyancyForce *= 1.0 - 0.001 * _DeltaTime;

	float2 wind = float2(1.0, 0.0) * 0.000001;

    _XOut[id] = float4(_Velocity[id] + vorticityForce + buoyancyForce + wind, 0.0, 0.0);
}

[numthreads(8, 8, 1)]
void UpdateThermodynamics(uint2 id : SV_DispatchThreadID)
{
	if (any(id >= _Resolution))
		return;

	float3 thermo = _Thermo[id].xyz;
	float q_v = thermo.x;
	float q_c = thermo.y;
	float theta = thermo.z;

	float airPressure = _AtmoLUT[uint2(id.y, 0)].y;
	float pi = exner(airPressure);
	float localTemp = theta * pi;
	float q_vs = getSaturationMixingRatio(localTemp, airPressure);

	float q_total = q_v + q_c;
	float excessWater = q_total - q_vs;
	float overSaturation = excessWater - q_c;

	float condensation;
	if (overSaturation < 0.0) {
		condensation = overSaturation * 0.20;
	} else {
		condensation = overSaturation * 0.002;
	}

	condensation = max(condensation, -q_c);

	float new_qv = q_v - condensation;
	float new_qc = q_c + condensation;
	float new_theta = theta + condensation * (L / (C_P * pi));

	float localTemp_c = KtoC(localTemp);
	float precipThreshold;
	if (localTemp_c > 0.0) {
		precipThreshold = 0.001;
	} else {
		precipThreshold = lerp(0.0005, 0.0001, saturate(-localTemp_c / 30.0));
	}

	float precipRate = 0.0;
	if (new_qc > precipThreshold) {
		float baseRate = 0.00001;

		if (localTemp_c < 0.0) {
			float iceGrowthMult = lerp(1.0, 3.0, saturate(-localTemp_c / 30.0));
			baseRate *= iceGrowthMult;
		}

		float excessCloud = new_qc - precipThreshold;
		precipRate = excessCloud * baseRate;
	}

	new_qc -= precipRate;

	if (precipRate > 0.0 && new_qv < q_vs) {
		float subsaturation = q_vs - new_qv;
		float evapFraction = 0.3; 
		float precipEvap = min(precipRate * evapFraction, subsaturation);

		new_qv += precipEvap;
		new_theta -= precipEvap * (L / (C_P * pi));
		precipRate -= precipEvap;
	}

	if (localTemp_c < 0.0 && new_qc > 0.0) {
		float freezingRate = min(new_qc * 0.0001, new_qc);
		new_theta += freezingRate * (334000.0 / (C_P * pi));
	} else if (localTemp_c > 0.0 && localTemp_c < 2.0) {
		float meltingCooling = precipRate * 0.5 * (334000.0 / (C_P * pi));
		new_theta -= meltingCooling;
	}

	float2 ambientState = getAmbientThermoState(id.y);
	float qv_ambient = ambientState.x;
	float theta_ambient = ambientState.y;
	
	float relaxRate = 0.0001;
	new_qv = lerp(new_qv, qv_ambient, relaxRate);
	new_theta = lerp(new_theta, theta_ambient, relaxRate);

	new_qv = max(new_qv, 0.0);
	new_qc = max(new_qc, 0.0);

	_XOut[id] = float4(new_qv, new_qc, new_theta, 0.0);
}

///////////////////////////////////////////////////////////////////////////
// Projection Part 1
///////////////////////////////////////////////////////////////////////////
[numthreads(8, 8, 1)]
void ProjectionPt1(uint2 id : SV_DispatchThreadID) {
	if (any(id >= _Resolution))
		return;

	_PressureOut[id] = 0;
	_Divergence[id] = -0.5f *
		((_Velocity[id + uint2(1, 0)].x - _Velocity[id - uint2(1, 0)].x) / _Resolution.x +
		 (_Velocity[id + uint2(0, 1)].y - _Velocity[id - uint2(0, 1)].y) / _Resolution.y);
}

///////////////////////////////////////////////////////////////////////////
// Projection Part 2
///////////////////////////////////////////////////////////////////////////
[numthreads(8, 8, 1)]
void ProjectionPt2(uint2 id : SV_DispatchThreadID) {
	if (any(id >= _Resolution))
		return;

	_PressureOut[id] =
		(_Divergence[id] +
			_PressureIn[id + uint2(1, 0)] + 
			_PressureIn[id - uint2(1, 0)] + 
			_PressureIn[id + uint2(0, 1)] + 
			_PressureIn[id - uint2(0, 1)]
		) / 4;
}

///////////////////////////////////////////////////////////////////////////
// Projection Part 3
///////////////////////////////////////////////////////////////////////////
[numthreads(8, 8, 1)]
void ProjectionPt3(uint2 id : SV_DispatchThreadID)
{
	if (any(id >= _Resolution))
		return;

	_Velocity[id] -= 0.5 * float2(
		(_PressureIn[id + uint2(1, 0)] - _PressureIn[id - uint2(1, 0)]) * _Resolution.x,
		(_PressureIn[id + uint2(0, 1)] - _PressureIn[id - uint2(0, 1)]) * _Resolution.y
	);
}

///////////////////////////////////////////////////////////////////////////
// Set Bounds
///////////////////////////////////////////////////////////////////////////
[numthreads(64, 1, 1)]
void SetBoundsX(uint id : SV_DispatchThreadID)
{
	if (id >= _Resolution.x * 2)
		return;

	bool isBottomEdge = id < _Resolution.x;
	int offset = isBottomEdge ? 1 : -1;
	uint2 edgeId = uint2(id % _Resolution.x, isBottomEdge ? 0 : _Resolution.y - 1);
	_XOut[edgeId] = _XIn[edgeId + int2(0, offset)] * float3(1, -1, 1);
}

[numthreads(64, 1, 1)]
void SetBoundsY(uint id : SV_DispatchThreadID)
{
	if (id >= _Resolution.y * 2)
		return;

	bool isLeftEdge = id < _Resolution.y;
	int offset = isLeftEdge ? 1 : -1;
	uint2 edgeId = uint2(isLeftEdge ? 0 : _Resolution.x - 1, id % _Resolution.y);
	_XOut[edgeId] = _XIn[edgeId + int2(offset, 0)] * float3(-1, 1, 1);
}